走进shell
========
索引
------
 + []()
 + []()
 + []()

### <span id='title_01'>走进shell</span>
+ linux手册页的内容区域

| 区域号 | 内容                     |
| ------ | ------------------------ |
| 1      | 可执行的程序或shell命令  |
| 2      | 系统调用                 |
| 3      | 库调用                   |
| 4      | 特殊文件                 |
| 5      | 文件格式和约定           |
| 6      | 游戏                     |
| 7      | 概览、约定以及杂项       |
| 8      | 超级用户和系统管理员命令 |
| 9      | 内核例程                 |

+ 文件系统
  * linux采用的单个目录结构，这些目录被称为虚拟目录
  * 虚拟目录只采用一个根的目录
  * linux安装的第一块磁盘被称为根驱动器，根驱动器包含的虚拟目录的核心，其他目录都是从哪里开始构建的
  * linux会在根驱动器上创建一些特殊的目录，```挂载点(mount point)```。挂载点是虚拟目录中用于分配额外存储设备的目录。
  * 链接文件
    - 链接是linux文件系统的一个优势，如果需要在同一文件系统上维持同一文件的两份或者多分副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法，这种虚拟的副本就叫做```链接```
    - 链接是目录中指向真实文件位置的占位符。
    - 软连接(符号链接)：就是一个真实存在的文件，他指向存放在虚拟目录结构中某个地方的另一个文件，```ln -s```,类似于windows的快捷方式。
    - 硬链接
  * file 查看文件类型命令
  * cat -n 文件显示行号 -b 只给有内容的显示行号 -T 不想让制表符出现
  * more less tail head
  * sort 按数字排序 -n 安值排序 -M按月份排序
  * tar -cvf 创建归档tar包   -tf 列出归档的内容  -zxvf解压tar包

### <span id='title_02'>进程列表</span>
#### 1 在一行运行一系列命令

  ```shell
  pwd;ls -l;cd 001;ls
  ```
  不过这不是进程列表,要想成为进程列表，这些命令必须加上括号。
  ```shell
  (pwd;ls -l;cd 001;ls)
  ```
  虽然看起来没有什么不同，但是括号的加入，使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。
  两种方式
  + ```(command group)```
  + ```{command group;}```
  要想查看是否生成了子shell需要借助一条命令```echo $BASH_SUBSHELL```
  ```(pwd;ls -al;cd cmake/;ls -al;echo $BASH_SUBSHELL)```
  ```(pwd;ls -al;cd cmake/;ls -al;(echo $BASH_SUBSHELL))```

#### 2 协程
  + 协程可以同时做两件事情，他在后台生成一个子shell，并在这个shell中执行命令
  + 要使用```coproc```命令，并且要在子shell中执行命令
  + ```coproc sleep 10```  ```coproc My_job {sleep 10;}```
  + 记住，生成子shell的成本不低，而且速度还慢创建嵌套子shell更是过上浇油

#### 3 理解shell的內建命令
##### 外部命令
+ 外部命令，又叫文件系统命令，是存在bash shell之外的程序，外部命令通常位于```/bin /usr/bin /sbin /usr/sbin```中
+ ```ps```是一个外部命令，可以使用```which type```找到他
+ 衍生，外部命令执行的时候，会创建出一个子进程
+ 当进程必须执行外部命令的时候(衍生操作)的时候，他会花费时间和精力来设置新的子进程的环境，所以说，外部命令多少是会有代价的。
##### 內建命令
+ 內建命令和外部命令的区别在于前者不需要子进程来执行，他们已经和shell成为了一体，作为shell工具的组成部分存在，不需要借助外部程序文件来执行。
+ ```cd exit```都內建与bash_shell，可以通过```type -a```来验证
+ 內建命令不需要衍生出子进程来执行，也不需要打开程序文件，內建命令的执行速度会更快，效率也就更快。

### <span id='title_03'>三 使用linux的环境变量</span>
#### 简介
    linux环境变量可以帮你提升linux的用户体验，很多程序和脚本可以通过环境变量来获取系统信息，存储临时数据和配置信息。

##### 1 全局环境变量
+ 全局环境变量对于shell会话和所有生成的子shell都是可见的
+ 对那些创建子shell需要获得父shell信息的程序是非常有用的。
+ 系统环境变量基本都采用大写，以区别普通用户环境变量
+ 设置全局环境变量的步骤
  - 方法一
    * 先创建一个局部环境变量
    * 使用```export```命令导出到全局环境中。
    * 修改子shell中的全局变量的值不影响父shell全局变量的值
    * 子shell无法通过export命令来改变父shell中全局环境变量的值
  - 删除环境变量
    * unset 环境变量名
##### 2 局部环境变量
+ 只对创建他的shell可见，只能在定义他们的进程中可见
+ set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量
###### 2.1 设置局部用户定义变量
+ 在子shell中不可以使用父shell的局部变量

#### PATH环境变量
+ 设置PATH环境变量
  - PATH环境变量定义了用于进行命令和程序查找的目录
  - ```PATH=$PATH:my_path```
  - 程序员经常把```.```放在PTAH环境变量中，这样就可以直接执行命令
  - 上述对PATH的修改只能持续到退出或者重启系统
+ 定位系统环境变量
  - 要使环境变量的作用持久化
  - 默认情况下bash会在几个文件中查找命令，这些文件叫做启动文件或环境文件
  - 启动shell的3种方式
    - 登录时做默认登录shell
    - 作为非登录shell的交互式shell
    - 作为运行脚本的非交互shell
+ 登录shell
  - 登录shell会从5个不同的启动文件中读取命令
    - ```/etc/profile```
    - ```$HOME/.bash_profile```
    - ```$HOME/.bashrc```
    - ```$HOME/.bash_login```
    - ```$HOME/.profile```



### <span id='title_01'></span>

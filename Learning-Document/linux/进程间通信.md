进程间通信
=========
主要内容
-------
+ 说出并了解管道的读写行为
+ 熟练使用pipe进行父子进程间的通信
+ 熟练使用pipe进行兄弟间的进程通信
+ 熟练使用fifo进行无血缘进程间的通信
+ 掌握mmap函数的使用
+ 使用mmap进行有血缘进程间的通信
+ 使用mmap进行无血缘关系之间的通信

### IPC
  + Linux环境下，进程地址空间相互独立，每个进程拥有不同的用户地址空间，任何一个进程的全局变量在另一个进程中是看不见的，所以进程之间不能互相访问</br>
  进程之间要交换数据，必须通过内核，内核通过在内存中开辟一块缓冲区，进程1把用户数据拷到内核缓存区，之后进程2在从内核缓存区中把数据读走</br>
  内核提供的这种机制称作进程间通信</br>
  + 内核提供的IPC方法有：文件、管道、套接字、信号、共享内存、消息队列等等
    - pipe 管道  (使用最简单)
    - fifo 命名管道   (无血缘关系的进程通信)
    - singnal 信号   (开销最小，携带信息量最小的)
    - mmap 共享内存区(无血缘关系，使用方便，速度快)
    - 本地套接字(最稳定)

### PIPE 管道
+ 本质是一个伪文件
+ 创建管道 pipe函数，通过函数，对管道创建两个文件描述符```fd[2]```
```int pipe(int fildes[2]);```
+ 只能有血缘之间的进程之间的通信
+ 管道属于半双工通信
+ 流程
  - 创建管道
  - 再创建子进程
  - 读写操作
+ 管道和文件描述符表之间的区别
  - 0，1，2 指向tty
  - fildes[0]3,fildes[1]4
+ 管道的读写行为
  - 1 读管道
    - 管道有数据
      - 正常读到数据
    - 管道无数据
      - 1 写端全部关闭：返回0-类似于读到文件末尾
      - 2 写端未全部关闭：读阻塞
  - 2 写管道
      - 1 读端全部关闭：进程会异常终止，造成管道破裂，sigpipe信号，说明异常
      - 2 读端未全部关闭
        - 管道已满：写阻塞，计算管道大小
        - 未满：继续写入
+ 管道缓存区大小ulimit -a 65536实际大小
+ 练习：实现|功能，将前一个命令结果给下一个命令    ps aux|grep bash
  - ps -- 标准输出
  - grep 是从标准输入读取数据

### fifo 命名管道
+ 先入先出，命名管道，有名管道
+ 机制：
  - 通过一个文件，内核有一块缓存区，之间建立了一个联系，通过文件找到内核的缓冲区
  - 打开文件，open，得到文件描述符
  - 通过文件描述符，对对应的内存缓存区进行读写操作。
  - 多个进程打开同一个fifo，就是相当于打开了同一块内核缓冲区。
+ 使用
  - 创建文件:```mkfifo myfifo```命令创建，创建了管道类型文件。
  - 借助管道文件对应同一块内存缓冲区，本质上，无血缘的进程可以通过管道文件，对内核缓冲区进行读写。
+ 缺点，无法控制谁来写，谁来读，无法正常分配fifo正常读写
+ 所以只能控制两个进程之间通信
+ fifo文件如果没有打开读端，只打开写端，那么会open函数会阻塞，等待read端打开

### mmap共享存储映射
+ 文件进程之间通信
  - 借助本地的磁盘文件，和内核建立一个映射关系
  - 优点：
    - 对内存的修改可以影响到源文件的内容

+ 使用
  - 建立映射区
    - ```void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);```
    - add地址，填NULL
    - length 长度，要申请的映射区的长度
    - prot权限
      - PROT_WRITE可写
      - PROT_READ可读
    - falgs标志位
      - MAP_SHARED 共享的 -- 对映射区的修改会影响源文件
      - MAP_PRIVATE 私有的  -- 对映射区的修改不会影响源文件
    - 返回值
      - 成功：返回营社区的首地址
      - 失败： 返回MAP_FIALED(void *(-1))
  - 释放映射区 ```int munmap(void *addr,size_t length)```
    - 释放映射区 释放映射区的首地址
    - 映射区的长度
    - 返回值
      - 成功 -- 返回0
      - 失败 -- 返回-1
  - mmap就问
    - 文件偏移量随便填一个数会怎么样
      - offset必须是4096的整数倍
      - mmap建立映射区必须是页的整数倍，是按页进行内存映射的
    - 如果文件描述符先关闭，对mmap映射有没有什么影响
      - 没有影响，映射区一旦建立，就和文件描述符就没有关系了
      - 文件描述符的真正作用是帮我们对文件建立文件映射区，一旦建立完成，就没问题了
    - 如果更改mem的变量，释放的时候munmap，传入mem还能成功吗
      - 不可以，参数无效
    - 如果对mem越界操作会怎么样
      - 可以进行越界操作，和文件大小有关系，最大可以写到文件最大。
      - 建议不要使用越界操作
    - open的时候，可以创建一个新的文件来创建映射区吗
      - 能不能有一个0大小的文件来创建映射区
      - 不可以，出现总线错误，一般是内存对齐产生的错误，文件必须有大小
      - 可以像拓展文件，之后就可以使用mmap函数了，使用truncate
    - open文件可以选择O_WRONLY，可以吗
      - 不可以，权限不足，因为要建立映射区，隐藏的至少一次读操作，必须要读权限
    - 当选择MAP_SHARED的时候，可以选择O_RDONLY，prot可以选择读写吗
      - 不可以，同样是权限不足
      - 建立映射区的权限要小于等于打开的文件的权限。
    - mmap什么情况下回报错
      - 很多情况
    - 如果不判断返回值会出现什么情况
      - 死的很难看
+ 利用mmap进行无血缘关系之间通信
+ 利用mmap进行有血缘之间的通信，父子之间进程通信

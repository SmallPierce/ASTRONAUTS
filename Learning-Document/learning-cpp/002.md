c++中const的用法
==============
c++中使用const代替define的作用。
### 1 const定义的常量是由数据类型检查的
const可以对静态数据进行对应的数据类型检查，而define是没有的，define只是简单的文本替换，不可以对数据类型进行检查
define宏定义不可以对数据类型进行检查，define定义的常量只是进行简单的文本替换，没有数据类型的安全检查。
### 2 有些调试程序可以对const进行调试，不可以对define定义的宏常量进行调试
### 3 define不方便控制变量的作用域，而const可以对变量的作用域进行控制
    当定义局部变量的时候，const修饰的变量作用域仅限于函数范围内
    #define修饰的常量作用域是到undef为止
### 4 const修饰函数的参数
    1 const只能修饰输入参数，不可以修饰输出参数
    2 函数的参数传递分为两个类型，值传递，地址传递，和引用传递
      1 值传递，不需要加const修饰，因为值传递相当于函数自动用实参的拷贝初始化形参，当函数体内改变形参是，只是改变了只是栈上的拷贝而不是实参的值
      2 地址传递，通过地址传递，我们可以通过地址访问实参的实际地址，这样，引用形参指针，就会对实参的内容进行修改，这是我们不希望看到的，所以我们需要增加const修饰相关的地址变量
      3 引用传递，我们在使用引用的时候，相当于我们直接指向实参的内存空间，如果我们不希望改变实参的内容，我们也需要增加const修饰该变量。
    3 用const修饰函数的返回值
    返回值不可以直接被修改，而且只能赋值给const修饰的变量
    4 const修饰的成员函数(函数定义体)
    任何不会修改数据成员的函数都应该加上const修饰，这样不小心修改了数据成员，或者调用了非const成员函数的时候编译器都会报错
    5 以传引用的方式给const取代传值
      缺省情况下，c++以传值的方式将对象传入或传出函数，除非你使用其他的特性，否则，函数的参数就会以实参的拷贝进行初始化，而函数的调用者会收到函数返回值的一个拷贝，这个拷贝由函数的拷贝构造函数生成。这就是传值成为一个代价不菲的操作。

## 六 内存、堆、栈、变量作用域和生存期


### c逻辑进程的内存分区模型
+ 概览
<!--![](assets/markdown-img-paste-20180323213904347.png)-->
<center><img width=80% height=80% src="assets/markdown-img-paste-20180323213904347.png"/></center>

| 内存分区                     | 功能                                                                                                          |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------- |
| 程序代码区（code data）      | 存放函数体的二进制代码                                                                                        |
| 静态数据区（data area）      | 也称全局数据区，包含的数据类型比较多，如：全局变量、静态变量、一般常量、字符串常量等。                        |
| 初始化的全局变量和静态变量区 | <font color='red'> 字符串常量是存放在静态数据区的常量区的，这部分内容是不许被修改的                           |
| 未初始化的全局变量和静态变量 | <font color='red'> 注： 静态变量的内存是进程结束后由操作系统释放 </font>                                      |
| 堆（heap）                   | 一般是由程序员分配和释放，若程序员不释放，进程结束后由操作系统自动释放，如，malloc*()，calloc（），free（）等 </br> 堆具有“大内存，手工分配，申请大小随意，可能会泄露等特点”，堆内存是由os分配给堆管理器来管理了，堆管理器向使用者（用户进程）提供API来使用堆内存。堆需要程序员自己释放，如果程序员在申请堆内存并使用后没有来得及释放，那么这块内存就丢失了，这就是我们说的内存泄露。例子|
| 栈区(stack)                  | 1 由操作系统自动分配释放，存放函数的参数值、局部变量的值。</br>2 栈作为内存中的存储存储结构，通常存放程序临时创建的局部变量，即大括号{}中定义的变量，其中还包括函数调用的时候其形参，返回值等。</br>3 栈的大小是有默认值的，如果申请的临时变量太大超过栈的大小，就会造成栈溢出。                                                     |
| 命令行参数区                 | 存放命令行参数和环境变量的值，如，通过main()函数传递的值                                                      |

+ 具体变量在内存分区中的模型
  ```c
  #include<stdio.h>
  int a=0;                            //=======>全局初始化变量区
  char p1;                            //=======>全局未初始化变量区

  int main(int argc, char const *argv[]) {
    int b;                            //=======>栈区
    char s[]="abc";                   //=======>栈区
    char p2;                          //=======>栈区
    char p3="123456";                 //=======>123456在常量区，p3在栈区
    static c=0;                       //=======>全局（静态）初始化区
    d1=(char)malloc(10);              //=======>分配10字节的区域就在堆区
    d2=(char)malloc(20);              //=======>分配20字节的区域就在堆区
    printf("%p\n",p1);
    printf("%p\n",p2);
    return 0;
  }


### 静态数据区
+ 变量的作用域
<!--![](assets/markdown-img-paste-20180324145013940.png)-->
<center><img width=80% height=80% src='assets/markdown-img-paste-20180324145013940.png'></center>





+ 局部变量和静态局部变量
+ 字符串常量和字符串变量
  - c语言中，在一个双引号 “” 内的字符序列或者转义字符序列称为字符串变量。
    <font color='grey'>例如："HA HA" "abc" "\n\t"</font>
    这些字符串常量是不允许改变的，如果试图改变指针所指向位置的值是错误的。
    ```c
    char * str="hello world";
    * str='h';//操作是不允许的，会编译报警，执行报错；
    ```
  - c中没有纯粹的字符串变量，可以通过一个字符数组来实现。
    ```c
    char str[]="hello world";
    * str='h';//可以修改，相当于修改str第一个指针指向的内存的值。
    ```
  - 一个对比
    ```c
       #include<stdio.h>
       int main()
      {
        char * str="hello world";
        printf("%s\n",str);
        * str='C';
        printf("%s\n",str);
        return 1;
      }
      //编译报警，执行会报错，不可以更改常量区的值
    ```
    ```c
    #include <stdio.h>
    int main()
    {
      char str[]="hello world";
      printf("%s\n",str);
      * str='C';
      printf("%s\n",str);
      return 1;
    }
    //可以修改，执行成功。数组存放在
    ```
  - 字符串变量究竟存放在什么地方
    ```c
    #include<stdio.h>
    char * getstr()
    {
      char *str="hello a world";
      //字符串常量，存放在静态数据区，编译的时候由编译器分配。
      return str;
    }

    char * getstr1()
    {
    char str[]="hello b world"//字符串变量，函数调用时候，有栈来分配字符串变量的内存。
    printf("%d,%s\n",(int)str,str);
    return  str;
    }

    int main()
    {
    char * str=NULL;
    str=getstr();//我们将字符常量的地址给了我们自己定义的字符串指针，指向我们静态区的地址，实现了静态区数据的读取
    printf("%s\n",str);
    //尝试改写静态数据区的数据
    * str='C';
    printf("%s\n",str)
    //程序执行报错 21311 bus error，不允许修改相关的内容
    str=getstr1();//调用getstr1函数，获取里面生成数组的地址
    printf("%d,%s\n",(int)str,str);
    //捕获到函数内字符串变量的地址
    //无法打印出相关的内容，这是因为在函数调用完成后，给函数分配的栈空间会被回收。相应的字符串分配的内存也被回收，所以无法打印出内容。
    //尝试修改改地址的内容。
    * str='c';
    printf("%d,%s\n",(int)str,str);
    //修改失败，说明栈的生长也是由系统分配的，程序是没有权限直接越界访问内存的。
    return 1;
    }
    ```
    <!--![](assets/markdown-img-paste-20180324120317281.png)-->
    <center><img src="assets/markdown-img-paste-20180324120317281.png"/></center>

### 内存泄露

### c语言的内存分配函数
+ malloc
  - 函数原型： ```void *malloc(size_t __size)  ```
  - 参数说明： ```size```是所需要分配内存的空间大小，是指字节
  - 返回值类型： ```void *``` 表示未确定返回值的类型
               成功： 返回指向该内存的地址
               失败： 返回NULL
    <font color='grey'>注：c，c++规定，```void *```可强制转换成任何其他类型的指针。</font>
  - 函数功能: 表示向系统申请分配指定 size 个字节的内存空间
  - eg:
    ```c
    int *a = malloc(4);  //申请4个字节的空间用于存放一个int类型的值
    char *b = malloc(2); //申请2个字节的空间用于存放一个char类型的值
    ```
+ calloc
  - 函数原型： ```void *calloc(size_t __count, size_t __size)```
  - 参数说明： ```size```是单位个需要分配内存的空间大小，是指字节。```count```表示个数。
  - 返回值类型： ```void *``` 表示未确定返回值的类型
              成功： 返回指向该内存的地址
              失败： 返回NULL

  - 函数功能: 表示向系统申请分配 count 个长度为 size 一共为 count 乘以 size 个字节长度的连续内存空间，并将每一个字节都初始化为 0
  - eg:
    ```c
    int *c = calloc(10, sizeof(int)); 申请10个sizeof(int) 字节的空间
    char *d = calloc(2, sizeof(char)); 申请10个sizeof(char) 字节的空间
    ```
+ calloc
  - 函数原型： ```void *realloc(void *__ptr, size_t __size))```
  - 参数说明： ```size```是单位个需要分配内存的空间大小，是指字节。```ptr```表示需要修改的内存空间地址。
  - 返回值类型： ```void *``` 表示未确定返回值的类型
              成功： 返回指向该内存的地址
              失败： 返回NULL

  - 函数功能: 表示更改已经配置好的内存空间到指定的大小
  - eg:
    ```c
    char *d = calloc(2, sizeof(char));  //申请2个sizeof(char) 字节的空间
    char *f = realloc(d, 5 * sizeof(char));  //将原来变量d指向的2个sizeof(char) 字节的空间更改到5个sizeof(char) 字节的空间并由变量f指向。
    ```
+ free
  - 函数原型：```void free(void *)```
  - 参数说明：```void *```表示需要释放的内存空间对应的内存地址。
  - 返回值类型：返回值为空。
  - 函数功能：```free```表示用来释放已经动态分配的内存空间。```free()``` 可以释放由``` malloc()```、```calloc()```、```realloc()``` 分配的内存空间，以便其他程序再次使用。
  - eg：
    ```c
    char *g = malloc(sizeof(char)); //申请sizeof(char)大小内存空间
    free(g);      //释放掉g指针指向的内存空间
    g = NULL;     //将g指针指向NULL
    ```
  - <font color='grey'>注意：
    - free() 不会改变 传入的指针的值，调用 free() 后它仍然会指向相同的内存空间，但是此时该内存已无效，不能被使用。所以建议将释放完的指针设置为 NULL。</br>
    - free()只能释放动态分配的内存，并不能释放任意分配的内存。</font>
### static的用法和全局变量与局部变量
  + 4.1 什么是static
    static 是c和c++中很常用的修饰符，它被用来控制变量的存储方式和可见性。
    两句话：使用static有两个好处，<font color='green'>延长生存期和控制作用域，也就是说对外隐藏，对内处处可见</font>。
  + 4.1.2 static的引入
    在函数内部定义的变量，当程序执行到他的定义的时候，会在栈区为它分配相应的内存，函数在内存中分配的栈空间会在函数完成之后会被释放掉。这就会产生一个问题，如果我们想将此函数中的变量值保留到下一次调用时？
    一个方法是使用全局变量，但定义一个全局变量有许多的缺点，最明显的缺点就是破坏了该变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数的限制）。static关键字则可以很好的解决这个问题。
    另外，c++。需要一个数据对象为整个类而非整个对象来服务，同时，有力求不破坏类的封装性，即要求此成员会隐藏在类的内部，对外不可见，可以定义静态数据。
  + 4.1.3 静态数据的存储
    存储在静态数据区的变量会在程序刚开始运行的时候就完成初始化，也是唯一的一次初始化。
    - 在C++中static的内部实现机制
      静态数据成员要在程序一开始运行时候就必须存在。因为函数在程序运行中被调用,所以静态成员不能在任何函数内分配空间和初始化。
        - 类的外部文件的头文件，那里有类的说明
        - 类定义的内部实现，那里有类成员的函数定义
        - 应用程序的main()函数前的全局数据申明和定义处。
    - 静态数据成员要实际分配空间，不能在类的申明中定义(只能申明数据成员)。<font  color='red'>类的申明只是申明一个类的"规格和尺寸"，并不进行实际的内存分配，所以在 类申明中写成定义是错误的。</font>他也不能在头文件中类申明的外部定义，会造成在多个使用该类的源文件中，对其重复定义。
    - static就是要告诉编译器，将变量存储在程序的静态存储区非栈上空间。静态数据成员按照出现的先后顺序，依次的完成初始化。静态成员进行嵌套的时候，要保证所嵌套的数据成员已经初始化了。消除的顺序是初始化的反顺序。
    - 优势：可以节省内存，因为他是所有对象所共有的，因此，对多个对象来说，静态成员数据只存储一份，供所有对象共用，值可以更新，可以提高时间效率。

### C/C++中的static作用
  + 2.1 总的来说
    - (a) 在修饰变量的时候，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生存周期，直到程序运行结束之后才释放
    - (b) static修饰的全局变量，只可以在本文件中访问，不可以在外部文件访问，既是是extern外部声明也不可以
    - \(c\) static修饰一个函数，该函数只可以在本文件中调用，在其他文件中不允许被调用。
    ><font color='red'>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</font></br>
    - (d) static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存，初始化的时候自动初始化为0。
    - (e) 不想被释放的时候，我们可以使用static修饰，比如，修饰函数存放在栈空间中的数组，如果不想让这个数组在函数结束之后被释放，可以使用static修饰，相当于在全局变量区中申请内存空间，在函数内部使用的时候再赋值。
    ><font color="green">在占用内存空间较大的局部数组声明的前面加static,将其从堆栈数据段挪到全局数据段,即可避开因局部数组大小超过默认堆栈大小1MB造成程序不能正常运行的问题。</font>
    - (f)

  + 2.2 静态变量和普通变量
  静态全局变量有一下的特点：
    - (a) 静态变量都在全局区分配内存，包括后面要说的静态局部变量。
    - (b) 未经初始化的静态变量会被程序自动的初始化为0，
      ><font color='grey'>注：在函数内部申明的自动变量的值是随机的，除非他被显式的初始化。如 ```int a = 10```，在函数体外申明的自动变量也被初始化为0。</font></br>
    - \(c\) 静态全局变量的声明在它的整个文件夹中都是可见的，在它的外部文件中是不可见的。</br>
  <font color='green'>
  优点：静态全局变量不能被其他文件所用；所以其他文件可以定义相同名字的变量，不会发生冲突。
  </font>
  + 2.3 静态局部变量的特点

### C++中静态变量的一些特点

  + 3.1 static在C++中的作用
  + 3.2 静态类相关
### 总结


### 进程和线程，栈和堆

### 函数的调用

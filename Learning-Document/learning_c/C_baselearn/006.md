## 六 内存、堆、栈、变量作用域和生存期


### c逻辑进程的内存分区模型
+ 概览
<!--![](assets/markdown-img-paste-20180323213904347.png)-->
<center><img width=80% height=80% src="assets/markdown-img-paste-20180323213904347.png"/></center>

| 内存分区                     | 功能                                                                                                          |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------- |
| 程序代码区（code data）      | 存放函数体的二进制代码                                                                                        |
| 静态数据区（data area）      | 也称全局数据区，包含的数据类型比较多，如：全局变量、静态变量、一般常量、字符串常量等。                        |
| 初始化的全局变量和静态变量区 | <font color='red'> 字符串常量是存放在静态数据区的常量区的，这部分内容是不许被修改的                           |
| 未初始化的全局变量和静态变量 | <font color='red'> 注： 静态变量的内存是进程结束后由操作系统释放 </font>                                      |
| 堆（heap）                   | 一般是由程序员分配和释放，若程序员不释放，进程结束后由操作系统自动释放，如，malloc*()，calloc（），free（）等 </br> 堆具有“大内存，手工分配，申请大小随意，可能会泄露等特点”，堆内存是由os分配给堆管理器来管理了，堆管理器向使用者（用户进程）提供API来使用堆内存。堆需要程序员自己释放，如果程序员在申请堆内存并使用后没有来得及释放，那么这块内存就丢失了，这就是我们说的内存泄露。例子|
| 栈区(stack)                  | 由操作系统自动分配释放，存放函数的参数值、局部变量的值。</br> 栈作为内存中的存储存储结构，通常存放程序临时创建的局部变量，即大括号{}中定义的变量，其中还包括函数调用的时候其形参，返回值等。                                                      |
| 命令行参数区                 | 存放命令行参数和环境变量的值，如，通过main()函数传递的值                                                      |

+ 具体变量在内存分区中的模型
  ```c
  #include<stdio.h>
  int a=0;                            //=======>全局初始化变量区
  char p1;                            //=======>全局未初始化变量区

  int main(int argc, char const *argv[]) {
    int b;                            //=======>栈区
    char s[]="abc";                   //=======>栈区
    char p2;                          //=======>栈区
    char p3="123456";                 //=======>123456在常量区，p3在栈区
    static c=0;                       //=======>全局（静态）初始化区
    d1=(char)malloc(10);              //=======>分配10字节的区域就在堆区
    d2=(char)malloc(20);              //=======>分配20字节的区域就在堆区
    printf("%p\n",p1);
    printf("%p\n",p2);
    return 0;
  }


### 静态数据区
+ 变量的作用域
<!--![](assets/markdown-img-paste-20180324145013940.png)-->
<center><img width=80% height=80% src='assets/markdown-img-paste-20180324145013940.png'></center>





+ 局部变量和静态局部变量
+ 字符串常量和字符串变量
  - c语言中，在一个双引号 “” 内的字符序列或者转义字符序列称为字符串变量。
    <font color='grey'>例如："HA HA" "abc" "\n\t"</font>
    这些字符串常量是不允许改变的，如果试图改变指针所指向位置的值是错误的。
    ```c
    char * str="hello world";
    * str='h';//操作是不允许的，会编译报警，执行报错；
    ```
  - c中没有纯粹的字符串变量，可以通过一个字符数组来实现。
    ```c
    char str[]="hello world";
    * str='h';//可以修改，相当于修改str第一个指针指向的内存的值。
    ```
  - 一个对比
    ```c
       #include<stdio.h>
       int main()
      {
        char * str="hello world";
        printf("%s\n",str);
        * str='C';
        printf("%s\n",str);
        return 1;
      }
      //编译报警，执行会报错，不可以更改常量区的值
    ```
    ```c
    #include <stdio.h>
    int main()
    {
      char str[]="hello world";
      printf("%s\n",str);
      * str='C';
      printf("%s\n",str);
      return 1;
    }
    //可以修改，执行成功。数组存放在
    ```
  - 字符串变量究竟存放在什么地方
    ```c
    #include<stdio.h>
    char * getstr()
    {
      char *str="hello a world";
      //字符串常量，存放在静态数据区，编译的时候由编译器分配。
      return str;
    }

    char * getstr1()
    {
    char str[]="hello b world"//字符串变量，函数调用时候，有栈来分配字符串变量的内存。
    printf("%d,%s\n",(int)str,str);
    return  str;
    }

    int main()
    {
    char * str=NULL;
    str=getstr();//我们将字符常量的地址给了我们自己定义的字符串指针，指向我们静态区的地址，实现了静态区数据的读取
    printf("%s\n",str);
    //尝试改写静态数据区的数据
    * str='C';
    printf("%s\n",str)
    //程序执行报错 21311 bus error，不允许修改相关的内容
    str=getstr1();//调用getstr1函数，获取里面生成数组的地址
    printf("%d,%s\n",(int)str,str);
    //捕获到函数内字符串变量的地址
    //无法打印出相关的内容，这是因为在函数调用完成后，给函数分配的栈空间会被回收。相应的字符串分配的内存也被回收，所以无法打印出内容。
    //尝试修改改地址的内容。
    * str='c';
    printf("%d,%s\n",(int)str,str);
    //修改失败，说明栈的生长也是由系统分配的，程序是没有权限直接越界访问内存的。
    return 1;
    }
    ```
    <!--![](assets/markdown-img-paste-20180324120317281.png)-->
    <center><img src="assets/markdown-img-paste-20180324120317281.png"/></center>

### 内存泄露

### c语言的内存分配函数
+ malloc
  - 函数原型： ```void *malloc(size_t __size)  ```
  - 参数说明： ```size```是所需要分配内存的空间大小，是指字节
  - 返回值类型： ```void *``` 表示未确定返回值的类型
               成功： 返回指向该内存的地址
               失败： 返回NULL
    <font color='grey'>注：c，c++规定，```void *```可强制转换成任何其他类型的指针。</font>
  - 函数功能: 表示向系统申请分配指定 size 个字节的内存空间
  - eg:
    ```c
    int *a = malloc(4);  //申请4个字节的空间用于存放一个int类型的值
    char *b = malloc(2); //申请2个字节的空间用于存放一个char类型的值
    ```
+ calloc
  - 函数原型： ```void *calloc(size_t __count, size_t __size)```
  - 参数说明： ```size```是单位个需要分配内存的空间大小，是指字节。```count```表示个数。
  - 返回值类型： ```void *``` 表示未确定返回值的类型
              成功： 返回指向该内存的地址
              失败： 返回NULL

  - 函数功能: 表示向系统申请分配 count 个长度为 size 一共为 count 乘以 size 个字节长度的连续内存空间，并将每一个字节都初始化为 0
  - eg:
    ```c
    int *c = calloc(10, sizeof(int)); 申请10个sizeof(int) 字节的空间
    char *d = calloc(2, sizeof(char)); 申请10个sizeof(char) 字节的空间
    ```
+ calloc
  - 函数原型： ```void *realloc(void *__ptr, size_t __size))```
  - 参数说明： ```size```是单位个需要分配内存的空间大小，是指字节。```ptr```表示需要修改的内存空间地址。
  - 返回值类型： ```void *``` 表示未确定返回值的类型
              成功： 返回指向该内存的地址
              失败： 返回NULL

  - 函数功能: 表示更改已经配置好的内存空间到指定的大小
  - eg:
    ```c
    char *d = calloc(2, sizeof(char));  //申请2个sizeof(char) 字节的空间
    char *f = realloc(d, 5 * sizeof(char));  //将原来变量d指向的2个sizeof(char) 字节的空间更改到5个sizeof(char) 字节的空间并由变量f指向。
    ```
+ free
  - 函数原型：```void free(void *)```
  - 参数说明：```void *```表示需要释放的内存空间对应的内存地址。
  - 返回值类型：返回值为空。
  - 函数功能：```free```表示用来释放已经动态分配的内存空间。```free()``` 可以释放由``` malloc()```、```calloc()```、```realloc()``` 分配的内存空间，以便其他程序再次使用。
  - eg：
    ```c
    char *g = malloc(sizeof(char)); //申请sizeof(char)大小内存空间
    free(g);      //释放掉g指针指向的内存空间
    g = NULL;     //将g指针指向NULL
    ```
  - <font color='grey'>注意：
    - free() 不会改变 传入的指针的值，调用 free() 后它仍然会指向相同的内存空间，但是此时该内存已无效，不能被使用。所以建议将释放完的指针设置为 NULL。</br>
    - free()只能释放动态分配的内存，并不能释放任意分配的内存。</font>
### static的用法和全局变量与局部变量
  + 什么是static
    static 是c和c++中很常用的修饰符，它被用来控制变量的存储方式和可见性。
  + static的引入
    在函数内部定义的变量，当程序执行到他的定义的时候，会在栈区为它分配相应的内存，函数在内存中分配的栈空间会在函数完成之后会被释放掉。这就会产生一个问题，如果我们想将此函数中的变量值保留到下一次调用时？
    一个方法是使用全局变量，但定义一个全局变量有许多的缺点，最明显的缺点就是破坏了该变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数的限制）。static关键字则可以很好的解决这个问题。
    另外，c++。需要一个数据对象为整个类而非整个对象来服务，同时，有力求不破坏类的封装性，即要求此成员会隐藏在类的内部，对外不可见，可以定义静态数据。
  + 静态数据的存储 
